
%% Implementatie
%%=============================================================================

\chapter{Prototype Implementation}%
\label{ch:implementatie}

% TODO: Add content for the implementation chapter here.
% This chapter should document the architecture of the web-based password manager.
% Cover the facial-authentication workflow, cryptographic handling of credentials
% with bcrypt, the WCAG-compliant user interface, and the modular codebase.

\section{Prototype Implementation}

\subsection{Architecture overview}
The password manager is implemented as a modern client-server web application.  
\begin{itemize}
  \item \textbf{Frontend} - a React single-page application (SPA) written in TypeScript delivers the user interface.  
  \item \textbf{Backend} - a Node.js\,/\,Express service, also in TypeScript, handles data persistence, face-recognition logic and JSON Web Token (JWT) issuance.  
  \item \textbf{Database} - user and credential data are stored in an SQLite file accessed through the Prisma ORM; a PostgreSQL target is available for future scaling.  
\end{itemize}

\subsection{Technology stack}
\paragraph{Frontend}
React {+} TypeScript, React Context API for state, Tailwind CSS components, Axios for REST calls, \texttt{crypto-js} for client-side AES-256 encryption, and \texttt{face-api.js} (TensorFlow.js) for in-browser face detection.

\paragraph{Backend}
Node.js 18, Express 4, TypeScript, Prisma, \texttt{face-api.js} running under \texttt{node-canvas} for server-side inference, JWT for session tokens, and the Node \texttt{crypto} module for cryptography.

\subsection{Face-authentication workflow}
\begin{enumerate}
  \item \textbf{Registration} - the browser captures a webcam frame, encrypts it with AES-256 under a user-specific key, and posts it to the server. After decryption, \texttt{face-api.js} extracts a 128-D descriptor that is stored with the user record.
  \item \textbf{Login} - a fresh frame is captured, encrypted and processed in the same way; its descriptor is compared to the stored vector with Euclidean distance~$\le0.6$.
  \item \textbf{Optimisation} - images are down-scaled (320\,$\times$\,240) and processed with TinyFaceDetector / MobileNet V1 models that are pre-loaded once at server start.
\end{enumerate}

\subsection{Secure credential vault}
\begin{itemize}
  \item Keys are derived client-side with PBKDF2 (10\,000 iterations, 16-byte salt).  
  \item All usernames and passwords are AES-256-CBC encrypted in the browser before transmission; only ciphertext is stored.  
  \item During retrieval the encrypted blobs are returned unchanged and decrypted locally, so plaintext secrets never leave the user's device.  
\end{itemize}

\subsection{Implementation roadmap}
Development progressed through the following incremental phases:

\begin{enumerate}[label=\textbf{Phase~\arabic*:}, leftmargin=2.5em]
  \item \emph{Requirements \& accessibility goals} - zero plaintext outside the browser and WCAG 2.2 AA compliance.%
  \item Dual-repo setup (\texttt{pwd-manager-frontend} \& \texttt{pwd-manager-backend}) merged into a monorepo with Nx, CI pipeline (ESLint, tests, Docker).%
  \item Core architecture: React + Vite SPA, Express API, Prisma models \emph{User} \& \emph{Credential}.%
  \item Face-authentication MVP using Tiny MobileNet V1 and in-browser matching.%
  \item End-to-end client-side cryptography (PBKDF2 $\rightarrow$ AES-256-CBC).%
  \item Credential-vault CRUD with optimistic UI updates and password-strength meter.%
  \item Transport security and DevOps: Nginx + Let's Encrypt, HSTS, CSP, multi-stage Docker images.%
  \item Accessibility pass and UI refinements.%
  \item Backup/restore via encrypted JSON and initial sync stubs for future cloud integration.%
  \item Quality assurance: Vitest, Jest, Playwright end-to-end tests, CI coverage $>$90\,\%.%
\end{enumerate}


\subsection{Database schema}
The \texttt{User} table stores the e-mail address and the 128-dimensional face descriptor; the \texttt{Credential} table stores website metadata together with encrypted username and password, and cascades on user deletion.


\subsection{Encryption and Decryption}\label{subsec:encryption}

All sensitive fields including passwords and webcam images are protected end-to-end with AES-256 encryption.
Keys are never transmitted in plaintext; instead they are derived client-side with PBKDF2 and reproduced server-side only when needed for decryption.

\subsubsection{Password encryption workflow}

\paragraph{Key derivation (PBKDF2).}
A 256-bit key is derived in the browser from a user-specific base key and a 16-byte salt, using 10000 iterations.

\begin{lstlisting}[language=TypeScript, caption={Key derivation function using PBKDF2}, label={lst:strengthen-key}]
export const strengthenKey = (baseKey: string): string => {
  return PBKDF2(baseKey, SALT, {
    keySize: KEY_SIZE / 32,   // 256 bits
    iterations: ITERATIONS,   // 10,000
  }).toString();
};
\end{lstlisting}

\paragraph{AES-256 encryption and decryption.}
The code below demonstrates the encryption and decryption functions used in the client. The encrypt function strengthens the provided key and uses AES to encrypt the value, while the decrypt function reverses this process with error handling.

\begin{lstlisting}[language=TypeScript, caption={AES-256 encryption and decryption functions}, label={lst:encrypt-decrypt}]
export const encrypt = (value: string, secretKey: string): string => {
  if (!value) return "";
  const strengthenedKey = strengthenKey(secretKey);
  return AES.encrypt(value, strengthenedKey).toString();
};

export const decrypt = (
  encryptedValue: string,
  secretKey: string
): string => {
  if (!encryptedValue) return "";
  try {
    const strengthenedKey = strengthenKey(secretKey);
    const bytes = AES.decrypt(encryptedValue, strengthenedKey);
    return bytes.toString(UTF8);
  } catch (error) {
    console.error("Failed to decrypt value:", error);
    return "";
  }
};
\end{lstlisting}

Each user obtains a unique secret based on their ID, e-mail and an application secret, as shown in the following function.

\begin{lstlisting}[language=TypeScript, caption={User-specific encryption key generation}, label={lst:user-key}]
export const getUserEncryptionKey = (
  userId: number,
  userEmail: string
): string => {
  const appSecretKey = import.meta.env.VITE_SECRET_KEY || "app-default-key";
  return `pwd-manager-${userId}-${userEmail}-${appSecretKey}`;
};
\end{lstlisting}

Before storage, credential fields are encrypted using the function below, which processes each sensitive field individually.

\begin{lstlisting}[language=TypeScript, caption={Encryption of credential fields before storage}, label={lst:encrypt-credential}]
const encryptCredential = (
  credential: CredentialEntry,
  encryptionKey: string
): EncryptedCredential => {
  return {
    ...credential,
    username: encrypt(credential.username, encryptionKey),
    password: encrypt(credential.password, encryptionKey),
    notes: credential.notes
      ? encrypt(credential.notes, encryptionKey)
      : undefined,
  };
};
\end{lstlisting}

\subsubsection{Face-image encryption workflow}

\paragraph{Client-side processing.}
A captured webcam frame is converted to Base64 and then encrypted with the same AES/PBKDF2 scheme, as demonstrated in the code below.

\begin{lstlisting}[language=TypeScript, caption={Client-side webcam image processing and encryption}, label={lst:image-processing}]
export const blobToBase64 = (blob: Blob): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      if (typeof reader.result === "string") {
        const base64 = reader.result.split(",")[1]; // strip data URL prefix
        resolve(base64);
      } else {
        reject(new Error("Failed to convert blob to base64"));
      }
    };
    reader.readAsDataURL(blob);
  });
};

export const encryptImage = async (
  imageBlob: Blob,
  encryptionKey: string
): Promise<{ encryptedData: string; contentType: string }> => {
  const base64Data = await blobToBase64(imageBlob);
  const encryptedData = encrypt(base64Data, encryptionKey);
  return { encryptedData, contentType: imageBlob.type };
};
\end{lstlisting}

Encrypted payloads are packaged into a `FormData` object for upload using the following utility function.

\begin{lstlisting}[language=TypeScript, caption={Creation of FormData for encrypted image upload}, label={lst:form-data}]
export const createEncryptedImageFormData = async (
  imageBlob: Blob,
  encryptionKey: string,
  fieldName: string = "image",
  additionalData: Record<string, string> = {}
): Promise<FormData> => {
  const { encryptedData, contentType } =
    await encryptImage(imageBlob, encryptionKey);

  const formData = new FormData();
  formData.append(`${fieldName}Encrypted`, encryptedData);
  formData.append(`${fieldName}ContentType`, contentType);
  formData.append(`${fieldName}IsEncrypted`, "true");
  Object.entries(additionalData).forEach(([k, v]) =>
    formData.append(k, v)
  );
  return formData;
};
\end{lstlisting}

\paragraph{Server-side decryption.}
The backend reproduces the key, then performs AES-256-CBC decryption as demonstrated in the server-side functions below.

\begin{lstlisting}[language=TypeScript, caption={Server-side decryption of encrypted data from the frontend}, label={lst:server-decryption}]
export const decryptFromFrontend = (
  cipherText: string,
  password: string
): Buffer => {
  const parts = cipherText.split(":");        // salt:iv:data
  const salt = Buffer.from(parts[0], "hex");
  const iv   = Buffer.from(parts[1], "hex");
  const encryptedData = Buffer.from(parts[2], "base64");

  const key = deriveKey(password, salt);      // PBKDF2
  const decipher = crypto.createDecipheriv(
    CRYPTO_CONFIG.algorithm, key, iv
  );
  return Buffer.concat([decipher.update(encryptedData), decipher.final()]);
};

export const decryptUserImage = (
  encryptedBase64: string,
  userId: number,
  userEmail: string
): Buffer => {
  const encryptionKey = getUserEncryptionKey(userId, userEmail);
  return decryptFromFrontend(encryptedBase64, encryptionKey);
};
\end{lstlisting}

\subsubsection{Security guarantees}

\begin{itemize}
  \item \textbf{End-to-end encryption}: passwords and images are encrypted in the browser; only ciphertext and face descriptors are stored.  
  \item \textbf{Per-user keys}: each key binds the user's ID and e-mail to an application secret, preventing key reuse across accounts.  
  \item \textbf{Key strengthening}: PBKDF2 with 10 000 iterations thwarts brute-force attacks on weak secrets.  
  \item \textbf{Compatible crypto}: frontend (\texttt{crypto-js}) and backend (\texttt{node:crypto}) use identical AES-256-CBC parameters, ensuring seamless decryption.  
\end{itemize}

